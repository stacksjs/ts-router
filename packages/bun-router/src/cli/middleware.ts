import fs from 'node:fs/promises'
import path from 'node:path'
import process from 'node:process'
import { chalk } from './colors'
import { middleware } from '../../src/middleware'

/**
 * Options for the middleware:types command
 */
export interface GenerateMiddlewareTypesOptions {
  output?: string
  watch?: boolean
}

/**
 * Options for the middleware:map command
 */
export interface MapMiddlewareOptions {
  output?: string
  dir?: string
  watch?: boolean
}

/**
 * Generate TypeScript types for middleware configurations
 */
export async function generateMiddlewareTypes(outputPath: string): Promise<void> {
  // Get middleware information
  const middlewareInfo = Object.entries(middleware).map(([key, instance]) => ({
    name: key,
    className: instance.constructor.name,
  }))

  // Generate type definition
  const typeContent = `/**
 * This file is auto-generated.
 * DO NOT EDIT THIS FILE DIRECTLY.
 * To update, run 'bun router middleware:types'
 */
import type { ${middlewareInfo.map(m => m.className).join(', ')} } from './middleware'

/**
 * Available middleware map with middleware names as keys
 */
export interface MiddlewareMap {
${middlewareInfo.map(m => `  '${m.name}': ${m.className}`).join('\n')}
}

/**
 * String literal type of available middleware names
 */
export type MiddlewareName = ${middlewareInfo.map(m => `'${m.name}'`).join(' | ')}

/**
 * Middleware configuration type for router setup
 */
export type MiddlewareConfig = MiddlewareName | ${middlewareInfo.map(m => m.className).join(' | ')}

/**
 * Function to check if a middleware name is valid
 */
export function isValidMiddleware(name: string): name is MiddlewareName {
  return [${middlewareInfo.map(m => `'${m.name}'`).join(', ')}].includes(name)
}
`

  // Write to file
  await fs.writeFile(outputPath, typeContent)
}

/**
 * Find TypeScript files in a directory recursively
 */
async function findTsFiles(dir: string): Promise<string[]> {
  const files: string[] = []
  const entries = await fs.readdir(dir, { withFileTypes: true })

  for (const entry of entries) {
    const fullPath = path.join(dir, entry.name)
    if (entry.isDirectory()) {
      files.push(...await findTsFiles(fullPath))
    }
    else if (entry.isFile() && entry.name.endsWith('.ts')) {
      files.push(fullPath)
    }
  }

  return files
}

/**
 * Scan a file for middleware classes
 */
async function scanFileForMiddleware(filePath: string): Promise<{ name: string, path: string }[]> {
  const middlewareClasses: { name: string, path: string }[] = []

  try {
    const content = await fs.readFile(filePath, 'utf-8')

    // Look for class declarations that implement Middleware or have "Middleware" in their name
    const classRegex = /export\s+(?:default\s+)?class\s+(\w+)\s+(?:implements\s+Middleware|\{[\s\S]*?handle\s*\([\s\S]*?\))/g
    let match: RegExpExecArray | null = null

    // eslint-disable-next-line no-cond-assign
    while (match = classRegex.exec(content)) {
      const className = match[1]

      // If the class name indicates it's middleware or it implements Middleware interface
      if (className.includes('Middleware') || match[0].includes('implements Middleware')) {
        const relativePath = path.relative(process.cwd(), filePath)
        // Remove extension for import path
        const importPath = relativePath.replace(/\.ts$/, '')
        middlewareClasses.push({
          name: className,
          path: importPath,
        })
      }
    }
  }
  catch (error) {
    console.warn(chalk.yellow(`Error scanning file ${filePath}: ${error}`))
  }

  return middlewareClasses
}

/**
 * Generate middleware type mappings for user project
 */
export async function generateMiddlewareMap(
  directoryPath: string,
  outputPath: string,
): Promise<void> {
  console.log(chalk.blue(`Scanning directory: ${directoryPath} for middleware classes...`))

  try {
    // Find all TypeScript files in the directory
    const tsFiles = await findTsFiles(directoryPath)
    const allMiddleware: { name: string, path: string }[] = []

    // Scan each file for middleware
    for (const file of tsFiles) {
      const middlewareInFile = await scanFileForMiddleware(file)
      allMiddleware.push(...middlewareInFile)
    }

    if (allMiddleware.length === 0) {
      console.warn(chalk.yellow('No middleware classes found in the specified directory.'))
      return
    }

    // Generate the type definition
    const imports = allMiddleware.map(m => `import { ${m.name} } from '${m.path}'`).join('\n')
    const interfaceMembers = allMiddleware.map(m => `  ${m.name}: typeof ${m.name}`).join('\n')
    const typeNames = allMiddleware.map(m => m.name).join(' | ')

    const typeContent = `/**
 * This file is auto-generated.
 * DO NOT EDIT THIS FILE DIRECTLY.
 * To update, run 'bun router middleware:map'
 */

${imports}

/**
 * Map of all available middleware in the project
 */
export interface MiddlewareMap {
${interfaceMembers}
}

/**
 * Type representing all available middleware classes in the project
 */
export type MiddlewareType = ${typeNames}

/**
 * Type for a middleware handler function
 */
export type MiddlewareHandler = (req: any, next: () => Promise<Response>) => Promise<Response>

/**
 * Ensure the middleware module exports all the middleware classes used in the project
 */
export const middlewareMap: MiddlewareMap = {
${allMiddleware.map(m => `  ${m.name}: ${m.name}`).join(',\n')}
}
`

    // Write to file
    await fs.writeFile(outputPath, typeContent)
    console.log(chalk.green(`✨ Middleware map generated at ${outputPath} with ${allMiddleware.length} middleware classes`))

    // List found middleware
    console.log(chalk.blue('Found middleware classes:'))
    for (const m of allMiddleware) {
      console.log(chalk.cyan(`  - ${m.name} (${m.path})`))
    }
  }
  catch (error) {
    console.error(chalk.red(`Error generating middleware map: ${error}`))
    throw error
  }
}

/**
 * Watch for changes in the directory and regenerate middleware map
 */
export async function watchDirectoryForMiddleware(
  directoryPath: string,
  outputPath: string,
): Promise<void> {
  // Check if directory exists
  try {
    await fs.access(directoryPath)
  }
  catch {
    console.error(chalk.red(`Directory not found at ${directoryPath}`))
    process.exit(1)
  }

  // Initial generation
  await generateMiddlewareMap(directoryPath, outputPath)
  console.log(chalk.blue(`Watching for changes in ${directoryPath}...`))

  // Setup file watcher
  let timeoutId: NodeJS.Timeout | null = null
  const watcher = fs.watch(directoryPath, { recursive: true })

  for await (const _event of watcher) {
    // Debounce to avoid multiple regenerations when multiple files change
    if (timeoutId) {
      clearTimeout(timeoutId)
    }

    timeoutId = setTimeout(async () => {
      console.log(chalk.yellow(`Changes detected. Regenerating middleware map...`))
      try {
        await generateMiddlewareMap(directoryPath, outputPath)
      }
      catch (error: any) {
        console.error(chalk.red(`Error regenerating middleware map: ${error.message}`))
      }
      timeoutId = null
    }, 500)
  }
}

/**
 * Watch for changes in the middleware directory and regenerate types
 */
export async function watchMiddlewareDirectory(outputPath: string): Promise<void> {
  const middlewarePath = path.join(process.cwd(), 'src', 'middleware')

  // Check if middleware directory exists
  try {
    await fs.access(middlewarePath)
  }
  catch {
    console.error(chalk.red(`Middleware directory not found at ${middlewarePath}`))
    process.exit(1)
  }

  // Initial generation
  await generateMiddlewareTypes(outputPath)
  console.log(chalk.green(`✨ Middleware types generated at ${outputPath}`))
  console.log(chalk.blue(`Watching for changes in ${middlewarePath}...`))

  // Setup file watcher
  let timeoutId: NodeJS.Timeout | null = null
  const watcher = fs.watch(middlewarePath, { recursive: true })

  for await (const _event of watcher) {
    // Debounce to avoid multiple regenerations when multiple files change
    if (timeoutId) {
      clearTimeout(timeoutId)
    }

    timeoutId = setTimeout(async () => {
      console.log(chalk.yellow(`Changes detected in middleware directory. Regenerating types...`))
      try {
        await generateMiddlewareTypes(outputPath)
        console.log(chalk.green(`✨ Middleware types regenerated at ${outputPath}`))
      }
      catch (error: any) {
        console.error(chalk.red(`Error regenerating types: ${error.message}`))
      }
      timeoutId = null
    }, 500)
  }
}
